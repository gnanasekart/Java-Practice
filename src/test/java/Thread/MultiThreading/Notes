Introduction - Multi threading concept
Multitasking - Executing several task simultaneously is the concept of MT.
-> Process based MT - execution several task simultaneously, where each task is separate independent process.
Ex- OS level
-> Thread based MT - executing multi task simultaneously, where task is separate independent part of same program
and each independent part is called thread
Ex- Programmatic level

When compared with Old Language developing multi threaded applications in Java is very
easy because Java provide inbuild support for multi threading with Rich API.
(Thread, Runnable, ThreadGroup...)

Advantage:-
To reduce response time of the system and to improve performance.
the main important applications of MT
- To develop multimedia, animations, video games.
- To develop web & App servers, etc.

Defining a Thread ?
We can define a thread in two ways.
1. By Extending Thread Class

Class MyThread extends Thread { //This class defining a thread
    public void run() {
        for(int i=0; i<10; i++){  //this loop is Job of thread
        sout("child thread");
        }
    }
}

Class ThreadDemo {
    public static void main(String[] args){//main thread
        MyThread t = new MyThread();//main thread helps to create child thread obj
        t.start();//main thread starts child thread
        //child thread is responsible to execute run method

        for(int i=0; i<10; i++){//main thread responsible
            sout("main thread");
        }
    }
}

case 1 - Thread scheduler
- part of JVM
It is the part of JVM, it is responsible to schedule threads that is if multiple threads are waiting to get the chance of execution.
Then in which order threads will be executed by thread scheduler.
We can't expect algorithm followed by thread scheduler it is varied from JVM to JVM.
Hence we can't expect thread execution order and exact output.
Hence when ever situation comes to multi threading there is no gaurenty for exact output But we can provide several possible outputs.

from the above ThreadDemo class we can t.start() to call run() method

case 2-
Difference between t.start() and t.run()
t.start() => a new thread will be created which is responsible for execution of run method.
But in the case of t.run() a new thread wont be created and run method will be executed just like a normal method call
by main thread.
Hence in the above program if we replace t.start() with t.run(), then the output is
run method output follow by main method output. this entire output is produced by main thread.

case 3-
Importance of Thread.start() methods perform
start() {
1. Register this thread with thread scheduler
2. Perform all other mandatory activities
3. Invoke run() method
}

case 4-
Overloading of run()
Overloading of run method is always possible but thread class start method can invoke no argument run method.
Other overloaded method we have to call explicitly like a normal method call.

Example

public class Overload_run_method {
    public static void main(String[] args) {
       MyThread t = new MyThread();
       t.start();
    }
}
o/p - no-arg run

class MyThread extends Thread{
    public void run(){
        System.out.println("no arg run");
    }
    public void run(int i){
        System.out.println("int arg run");
    }
}

case 5-
If we are not overriding run method - there is no any implementation/overriding of run method.
Then it will call the default run method (thread.run()) - which has empty implementation. it does not return any output.

Example

public class Overload_run_method {
    public static void main(String[] args) {
       MyThread t = new MyThread();
       t.start();
    }
}
o/p - no output

class MyThread extends Thread{

}

Note - recommended to override run method, otherwise not required for multi threading concept.

case 6-
Overriding of start method
If we override start method then our start method will be executed just like a normal method call and new thread wont be created.
priority goes first to child method only than thread class start method.

Example

public class Overload_start_method {
    public static void main(String[] args) {
        MyThreadStart t = new MyThreadStart();
       t.start();
        System.out.println("main method");
    }
}

class MyThreadStart extends Thread{
    public void start(){
        System.out.println("start method");
    }
    public void run(){
        System.out.println("run method");
    }
}
output-
start method
main method

this outputs are produced by only main thread
Note - it is not recommended to override start method, otherwise don't go for multi thread concept.

case 7-
By calling super class thread method

public class Overload_start_method {
    public static void main(String[] args) {
        MyThreadStart t = new MyThreadStart(); // main thread
       t.start();                              // main thread
        System.out.println("main method");
    }
}

class MyThreadStart extends Thread{
    public void start(){                    // main thread
        super.start();                      // create child thread
        System.out.println("start method"); // main thread
    }
    public void run(){                      // child thread take care of run() from start()
        System.out.println("run method");
    }
}

output-
start method
main method
run method
or
start method
run method
main method

case 8-
Life cycle of thread
image refer one note

case 9-
once we create a thread by thread.start() and again we try to restart the same thread, then it throws
IllegalThreadStateException

-------------------------------------------------------------------------------------------------------------

Approach 2- By Implementing Runnable Interface
Runnable interface present in Java.lang package and it contain only one method run()

class MyRunnable implements Runnable {
    public void run() { //child thread
        for(int i=0; i<10; i++){
        sout("child thread");
        }
    }
}

class ThreadDemo {
public static void main(String[] args){
    MyRunnable r = new MyRunnable();
    Thread t = new Thread(r); //r - target runnable
    t.start();
     for(int i=0; i<10; i++){//main thread
     sout("main thread");
     }
}

case study based on above code-

MyRunnable r = new MyRunnable();
Thread t1 = new Thread();
Thread t2 = new Thread(r);

case 1:- t1.start();
Create a new thread, which is responsible for the execution of thread.run(), which has empty implementation.

case 2:- t1.run();
no new thread will be created, and thread class run() will be executed just like a normal method call.

case 3:- t2.start();
A new thread will be created which is responsible for the execution of my runnable class run method.

case 4:- t2.run();
No new thread created and MyRunnable - will call the run method as normal method call.

case 5:- r.start();
we will compile time error saying MyRunnable class doesn't have start capability.
CE: Cannot find symbol
symbol: method start()
location: class MyRunnable

case 6:- r.run();
No new thread will be created and MyRunnable - run method will be executed as normal method call.

Which approach is best to define a thread ?
Among two ways of defining a thread implement runnable approach is recommended.
In the first approach our class always extends thread class, there is no chance of extending any other class.
Hence we are missing inherit. But in another approach by implementing Runnable interface we can extend any other class.

--------------------------------------------------------------------

Thread class constructors
Thread t = new Thread();
Thread t = new Thread(Runnable r);
Thread t = new Thread(String name);
Thread t = new Thread(Runnable r, String name);
Thread t = new Thread(ThreadGroup g, String name);
Thread t = new Thread(ThreadGroup g, Runnable r);
Thread t = new Thread(ThreadGroup g, Runnable r, String name);
Thread t = new Thread(ThreadGroup g, Runnable r, String name, long StackSize);

--------------------------------------------------------------------

Another method to define a thread hybrid approach

public class ThreadDemo {
    public static void main(String[] args) {
        MyThreadStart t = new MyThreadStart();
        Thread t1 = new Thread(t);
        t1.start();
        System.out.println("main method");
    }
}

class MyThreadStart extends Thread{
    public void run(){
        System.out.println("child thread");
    }
}
output-
child
main
or main
child

--------------------------------------------------------------------

Getting and Setting name of a thread

public class ThreadDemo {
    public static void main(String[] args) {
        //get name of the thread
        Thread.currentThread().getName();//main

        MyThreadStart t = new MyThreadStart();
        t.getName(); //thread-0

        //Set thread name
        Thread.currentThread().setName("sekar");

        System.out.println(Thread.currentThread().getName());
        System.out.println(10/0);
    }
}

class MyThreadStart extends Thread{

}

----------------------------------------------------------------------------------------
3. Thread Priorities
Every thread in java has some priority it may be default priority generated by JVM or customized priority provided by programmer.
The valid range of thread priority is 1 to 10. 1 = min and 10 is max
some standard priority
Thread.MIN_PRIORITY - 1
Thread.NORM_PRIORITY - 5
Thread.MAX_PRIORITY - 10

Who going to use thread priority ?
Thread scheduler will use priorities while allocating processor. That thread which have high priority will get first chance.
If both thread have same priority then we cannot expect exact execution order. It depends on thread scheduler.


How to get and set the priority of a thread ?
public final int getPriority()
public final void setPriority(int p)
p range -> 1 to 10
For Out of range - RE - IllegalArgumentException

Ex-
t.setPriority(7);
t.setPriority(71);-> RE

The default priority only for the main thread is 5, but for all the remaining threads.
the default priority will be inherited from parent to child.
That is whatever priority parent thread has the same priority will be there for child thread.
Ex-
public class ThreadPriority {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getPriority());
        //Thread.currentThread().setPriority(15); -> RE
        Thread.currentThread().setPriority(7);
        MyThreadP t = new MyThreadP();
        System.out.println(t.getPriority());//7
    }
}

class MyThreadP extends Thread {

}

Example 2
public class ThreadPriority1 {

    public static void main(String[] args) {

        MyThreadP1 t = new MyThreadP1();
        t.setPriority(10);
        t.start();
        for (int i = 0; i < 10; i++)
            System.out.println("main thread");
    }
}

class MyThreadP1 extends Thread {
    public void run() {
        for (int i = 0; i < 10; i++)
            System.out.println("child thread");
    }
}


Some platforms won't provide support for thread priorities.

----------------------------------------------------------------------------

4. Method to prevent Thread execution
- yield()
- join()
- sleep()


yield();
yield method causes to pause current executing thread to give the chance for waiting threads of same priority.
If there is no waiting thread or all waiting threads have low priority then same thread can continue its execution.
If multi waiting threads and current executing thread have same priority means which waiting thread will get the chance ? we can't expect it depends on thread scheduler.
the thread which is yielded, when it will get the chance once again it depends on thread scheduler. and cannot expect exactly.

public static native void yield();

If a running thread called yield method, then it will move to ready/runnable method.

public class YieldDemo {
    public static void main(String[] args) {
        MyThread myt = new MyThread();
        myt.start(); // will call no argument run method
        for (int i = 0; i < 10; i++) {
            System.out.println("main thread");
        }
    }
}

public class MyThread extends Thread{
    public void run(){
        MyThread my = new MyThread();
        my.setPriority(MAX_PRIORITY);
        for (int i = 0; i < 10; i++) {
            System.out.println("child thread");
            my.yield();
        }
    }
}

o/p-
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread

Child thread calls yield method, so main thread will get more chance more no of time,
and the chance of complete main thread first is high.

------------------------------------------------------

Join method
If a Thread wants to wait until completing some other thread. Then go for join method.

For Example - If a thread t1 want to wait until completing t2. then t1 has to call t2.join();
If t1 executes t2.join() then immediately t1 will be entered into waiting state until t2 completes.
Once t2 completes then t1 can continue its execution.

Example 2 consider marriage as example

hall booking (t1)  ~~~~~~~~~~~~~~~~~

wedding cards (t2) ~~~~t1.join();
printing

wedding card  (t3) ~~~~t2.join();
distribution

t2 event is dependency on t1 event
And t3 is dependency on t2 event

protocol -

public final void join() throws InterruptedException
public final void join(long ms);//waiting for some time
public final void join(long ms, int ns);//waiting for some time with nano seconds

Note-
every join method throws InterruptedException - checked exception
while a thread is waiting

case 1 -

public class JoinDemo {
    public static void main(String[] args) throws InterruptedException {
        MyThreadJoin myt = new MyThreadJoin();
        myt.start();
        //myt.join(); // first child thread complete and main thread will continue
        myt.join(10000);//wait for 10 sec and execute both thread simultaneously
        for (int i = 0; i < 10; i++) {
            System.out.println("main thread");
        }
    }
}

public class MyThreadJoin extends Thread{
    public void run(){
        for (int i = 0; i < 10; i++) {
            try {
                System.out.println("child thread");
                 Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}


output -
child thread
child thread
child thread
child thread
child thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
child thread
child thread
child thread
child thread
child thread

case 2 - waiting of child thread until completing of main thread
public class JoinDemoChildThread {
    public static void main(String[] args) throws InterruptedException {
        MyThreadJoinChild.t = Thread.currentThread();
        MyThreadJoinChild myt = new MyThreadJoinChild();
        myt.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("main thread");
            Thread.sleep(2000);
        }
    }
}

class MyThreadJoinChild extends Thread{
    static Thread t;
    public void run(){
            try {
                t.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        for (int i = 0; i < 10; i++) {
            System.out.println("child thread");
        }
        }
    }

    Child thread calls join method on main thread object, hence child thread has to wait until completing main thread.
In this case output is
        main thread
        main thread
        main thread
        main thread
        main thread
        main thread
        main thread
        main thread
        main thread
        main thread
        child thread
        child thread
        child thread
        child thread
        child thread
        child thread
        child thread
        child thread
        child thread
        child thread

case 3- if main thread calls join method on child thread object and child thread calls join on main method object, then both the thread will wait forever
and the program will be in lock/paused. this is like dead lock.

case 4 - If a thread calls join method on the same thread itself. then the program fall in deadlock.
Thread.currentThread().join();

--------------------------------

Sleep method
not perform any operation for some time.

public static native void sleep(long ms) throws InterruptedException
public static void sleep(long ms, int ns) throws InterruptedException

If running thread calls sleep method
Thread.sleep(1000);
Thread.sleep(1000,100);

it will move to ready or runnable state once after
- if time expired
- If sleeping thread got interrupted

-----------------------------------

How a thread can interrupt another thread ?
A thread can interrupt a sleeping thread or waiting thread by using interrupt method of thread class.
public void interrupt();

If the target thread not in sleeping or waiting state, then there is no impact of interrupt call will be waited
until target thread entered into sleeping or waiting state.
If the target thread enter into sleeping or waiting state, then immediately
interrupt call will interrupt the target thread.
if the target thread never enter into sleeping or waiting state. In its life time
then there is no impact of interrupt call.
------------------------------------------

5. Synchronization
- Synchronized is the modifier applicable only methods and blocks, but not for class and variables.
- If multi thread trying to access on the same java object then there will be possible for data inconsistency.
- To avoid this we should go for synchronized keyword.
- If a method or block declared as synchronized then at a time only one thread is allow to execute
that method or block on the given object.
- So that data inconsistency will be resolved.

Advantage of synchronized keyword
- we can resolve data inconsistency problems

Disadvantage of synchronized keyword
- It increases waiting time of threads and creates performance problem. hence
if there is no specific requirement then it is not recommended to use synchronized keyword.

internally synchronization concept is implemented by using lock,
every object in java having a unique lock.
whenever we are using synchronized keyword then only lock concept is consider.

If a thread wants to execute synchronized methods on the given object.
- First i has to get lock of that object
- once thread got lock of the object, then it allow to execute any synchronized method on that object.
- Once method execution completed, automatically thread release the lock.

Acquiring and releasing lock internally takes care by JVM and programmer
not responsible for this activities.

While a thread executing synchronized method and given object the remaining thread
are not allowed to execute any synchronized method simultaneously on the same object.
But remaining threads are allow to execute non synchronized methods simultaneously.
class x{
sync m1();
sync m2();
m3();
}

t1 came to starts execute m1()
if t2 came to execute same m1() waiting state
t3 came to execute m2() waiting state
t4 came to execute m3() not wait

lock concept is implemented based on object but not based on method.

Every Object has two side as
synchronized area - this area accessed by only one thread at a time.
where ever we are performing update operations {add/remove/Delete/Replace}, that is where state of object changing.

non-synchronized area - This area is accessed by any no of threads simultaneously.
Where ever object state won't be changed like read operations

Example if one thread handling multiple object
//to avoid both the thread execute simultaneously we need to mention synchronized

class Display{
    public synchronized void wish(String name){
        for (int i = 0; i < 3; i++) {
            System.out.println("Good Mrng :");
            try{
                Thread.sleep(2000);
            }catch (InterruptedException e){ }
            System.out.print(name+"\n");
        }
    }
}

class MyThread extends Thread{
    Display d;
    String name;
    MyThread(Display d, String name){
        this.d=d;
        this.name=name;
    }
    public void run(){
        d.wish(name);
    }
}

public class SynchronizedDemo {
    public static void main(String[] args) {
        Display d1 = new Display();
        MyThread t1 = new MyThread(d1, "dhoni");
        MyThread t2 = new MyThread(d1, "sachin");
         t1.start();
         t2.start();
    }
}
Here the execution is in regular flow

output -
Good Mrng : dhoni
Good Mrng : dhoni
Good Mrng : dhoni
Good Mrng : sachin
Good Mrng : sachin
Good Mrng : sachin

Example 2 - If two object is handle by two different thread then synchronized keyword is not required.

public class SynchronizedDemo {
    public static void main(String[] args) {
        Display d1 = new Display();
        Display d2 = new Display();
        MyThread t1 = new MyThread(d1, "dhoni");
        MyThread t2 = new MyThread(d1, "sachin");
         t1.start();//both the thread execute simultaneously
         t2.start();
    }
}

Even though wish method is synchronized we will get irregular out.
because threads are operating on different java objects.
conclusion - If multi threads are operating on same java object then synchronization is required.
If multi threads are operating on multiple java object then synchronization is not required.

Class level lock
Every class in Java has a unique lock which is class level lock.
If a thread wants to execute a static synchronized method, then thread required
class level lock.
Once thread got class level lock then it is allow to execute any static synchronized method of that class.

Once method execution completes automatically thread releases the lock.
-----------------

class X {
static sync m1();
static sync m2();
static m3();
sync m4();
m5();
}

While a thread executing static synchronized method the remaining thread are not allowed to execute,
static synchronized method of that class simultaneously. But remaining threads are allowed to execute the following methods
simultaneously -
1. normal static methods
2. sync instance methods
3. normal instance methods


------------------------

Example

package Thread.Synchronized;

class DisplaySS{
    public synchronized void wish(){
        for (int i = 0; i < 10; i++) {
            System.out.print(i);
            try{
                Thread.sleep(500);
            }catch (InterruptedException e){ }
        }
    }

    public synchronized void displayChar(){
        for (int i = 65; i < 75; i++) {
            System.out.print((char) i);
            try{
                Thread.sleep(500);
            }catch (InterruptedException e){ }
        }
    }
}

class MyThreadSS extends Thread{
    DisplaySS d;
    MyThreadSS(DisplaySS d){
        this.d=d;
    }
    public void run(){
        d.wish();
    }
}

class MyThreadSSc extends Thread{
    DisplaySS d;
    MyThreadSSc(DisplaySS d){
        this.d=d;
    }
    public void run(){
        d.displayChar();
    }
}

public class StaticSyncDemo {
    public static void main(String[] args) {
        DisplaySS d = new DisplaySS();
        MyThreadSS t1 = new MyThreadSS(d);
        MyThreadSSc t2 = new MyThreadSSc(d);
        t1.start();
        t2.start();
    }
}
output - 0123456789ABCDEFGHIJ

--------------------------------------------------------------------
Synchronised Block over Synchronised method
If very few lines of the code required Synchronization then it is not recommended to declare entire method not as Synchronised.
We have to enclose those few lines of the code by using Synchronised block.
The main advantage of Synchronised block over Synchronised method is-
It reduces waiting time of threads and improves performances of the system.

case 1 - To get lock of current object-
Synchronised(this) {
----
----
----
}
this - if a thread got lock of current object then only it allowed to execute this area.

case 2 - To get lock of particular object 'b'
Synchronised(b) {
----
----
----
}
b - if a thread got lock of particular class b object then only it allowed to execute this area.

case 3 - To get class level lock

Synchronised(Display.class) {
----
----
----
}
Display.class - if a thread got class level lock of Display class, only it is allowed to execute this area.


Example 1 - single display object for two thread

public class SynchronizedBlockDemo {
    public static void main(String[] args) {
        Display d1 = new Display();
        MyThreadSB t1 = new MyThreadSB(d1, "dhoni");
        MyThreadSB t2 = new MyThreadSB(d1, "sachin");
         t1.start();//both the thread execute simultaneously
         t2.start();//output will be irregular flow
    }
}
//In the below case only some part of code required to be maintained in synchronized block instead of entire method
class Display{
    public void wishSB(String name){
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//lakhs of lines of code

        synchronized(this) {
            for (int i = 0; i < 3; i++) {
                System.out.print("Good Mrng :");
                try{
                    Thread.sleep(2000);
                }catch (InterruptedException e){ }
                System.out.print(name+"\n");
            }
        }

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//lakhs of lines of code
    }
}

class MyThreadSB extends Thread{
    Display d;
    String name;
    MyThreadSB(Display d, String name){
        this.d=d;
        this.name=name;
    }
    public void run(){
        d.wishSB(name);
    }
}

output -
Good Mrng :dhoni
Good Mrng :dhoni
Good Mrng :dhoni
Good Mrng :sachin
Good Mrng :sachin
Good Mrng :sachin

Example 2 - two display object for two thread

public class SynchronizedBlockDemo {
    public static void main(String[] args) {
        Display d1 = new Display();
        Display d2 = new Display();
        MyThreadSB t1 = new MyThreadSB(d1, "dhoni");
        MyThreadSB t2 = new MyThreadSB(d1, "sachin");
         t1.start();//both the thread execute simultaneously
         t2.start();//output will be irregular flow
    }
}

ir-regular output -

Good Mrng :Good Mrng :dhoni
Good Mrng :sachin
Good Mrng :sachin
Good Mrng :dhoni
Good Mrng :sachin
dhoni


Example 3 - class level lock

class DisplaySB{
    public void wishSB(String name){
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//lakhs of lines of code

        synchronized(DisplaySB.class) {
            for (int i = 0; i < 3; i++) {
                System.out.print("Good Mrng :");
                try{
                    Thread.sleep(2000);
                }catch (InterruptedException e){ }
                System.out.print(name+"\n");
            }
        }
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//lakhs of lines of code
    }
}

output -
Good Mrng :dhoni
Good Mrng :dhoni
Good Mrng :dhoni
Good Mrng :sachin
Good Mrng :sachin
Good Mrng :sachin

Example 4 - Primitive type variable block in not available
lock concept applicable for object types and class but not for primitives, hence we cannot pass
primitive as argument to synchronized block, otherwise we will get CE

class DisplaySB{
    public void wishSB(String name){
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//lakhs of lines of code
        int x = 10;
        synchronized(x) {
            for (int i = 0; i < 3; i++) {
                System.out.print("Good Mrng :");
                try{
                    Thread.sleep(2000);
                }catch (InterruptedException e){ }
                System.out.print(name+"\n");
            }
        }
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//lakhs of lines of code
    }
}

output -
java: unexpected type
  required: reference
  found:    int

------------------------------------------------------------------

Race Condition-
If multiple thread operating simultaneously on the same object and causing data inconsistency.
By using synchronized keyword we are resolving this race condition.

Object lock - every object in java is unique lock that is object lock.
when a thread want to execute instance synchronized method then that thread required object lock.

class level lock - every class in java is unique lock. when a thread want to execute static synchronized method then that thread required class lock.

While a thread executing synchronized method and given object is the remaining threads are allow to execute any other synchronized simultaneously on the same object ?
No

Is a thread can acquired multiple locks simultaneously ?
Yes, from different objects

class X {
    public synchronized void m1() { //here thread has lock of X object
    Y y = new Y();

    synchronized(y) {//here thread has lock of x and y
    Z z = new Z();
        synchronized (z) {
        -----//here thread has lock of x, y, z
        }
    }
    }
}


class main{

main() {
X x = new X();
x.m1();
}
}

What is synchronized statement ?
the statement present inside synchronized method or block.
--------------------------------------------------------------------------------

wait(), notify(), notifyAll()

- Two threads can communicate with each other by using wait, notify and notify all method.
- That thread which is expecting update is responsible to call wait method, then immediately will enter into waiting state.
- The thread which is responsible to perform update, after performing update it is responsible to call notify method, then waiting
thread will get that notification and continue its execution with those updated items.


- Above three methods present in Object class but not in the thread class.
- Thread class contains only some specific methods like start(), join(), sleep(), etc.
- But thread can call this method on any java object wait, notify, notifyAll.

Three main points to consider while a thread accessing wait, notify, notifyAll

1. If any thread want to call the wait method on any object, compulsory thread should be owner of that object
2. Second that thread should has lock of that object.
3. That thread should be in synchronized area
If that thread not in any of the state means it will throws RE: IllegalMonitorStateException

What happen if a thread calls wait() on any object ?
If a thread calls wait method on any object, it will immediately release the lock of that particular object and
entered into waiting state.

What happen if a thread calls notify() on an object ?
If a thread calls notify method on any object, it release the lock of that object but may not immediately.
Except wait, notify and notifyAll there is no other method where thread release the lock.

If a waiting thread got notify then which state it will go in thread life cycle?
it will go to another waiting state to get lock.
How it goes -
- if waiting thread got notification
- if time expired
- if waiting thread got interrupted
If waiting thread got lock it will move next to ready/runnable state.



method ||  Is thread release lock ?
yield()     no
join()      no
sleep()     no
wait()      yes
notify()    yes
notifyAll() yes

prototype-

public final void wait() throws Interrupted exception;
public final native void wait(long ms) throws Interrupted exception; - native method and wait for specific time only
public final void wait (long ms, int ms) throws Interrupted exception; - non native method

public final native void notify();
public final native void notifyAll();


Example 1

public class ThreadWait {
    public static void main(String[] args) throws InterruptedException {
      Threadloop t = new Threadloop();
      t.start();
      t.wait();
      System.out.println(t.total);
    }
}

class Threadloop extends Thread {
    int total=0;
    public void run() {
        for (int i = 0; i <= 100; i++) {
            total+=i;
        }
        this.notify();
    }
}

output - Exception in thread "main" java.lang.IllegalMonitorStateException: current thread is not owner

Example 2
public class ThreadWait {

    public static void main(String[] args) throws InterruptedException {
      Threadloop t = new Threadloop();
      t.start();
      synchronized (t){
          t.wait();
      }
      System.out.println(t.total);
    }
}

class Threadloop extends Thread {
    int total=0;
    public void run() {
        for (int i = 0; i <= 100; i++) {
            total+=i;
        }
        this.notify();
    }
}

output -
Exception in thread "Thread-0" java.lang.IllegalMonitorStateException: current thread is not owner
	at java.base/java.lang.Object.notify(Native Method)
	at Thread.Wait_Notify_NotifyAll.Threadloop.run(ThreadWait.java:22)
5050

Example 3

public class ThreadWait {

    public static void main(String[] args) throws InterruptedException {
        Threadloop t = new Threadloop();
        t.start();
        synchronized (t) {
            t.wait();
        }
        System.out.println(t.total);
    }
}

class Threadloop extends Thread {
    int total = 0;

    public void run() {
        synchronized (this) {
            for (int i = 0; i <= 100; i++) {
                total += i;
            }
            this.notify();
        }
    }
}

output - 5050

Difference between notify() and notifyAll()

we can use notify method to give the notification for only one waiting thread.
If multiple threads are waiting then only one thread will be notify and the remaining thread have to wait for further notification.
Which thread will be notify we cannot expect it depends on JVM.


If there are two Objects which contains more no of waiting threads

obj1.wait(); => 60 threads waiting
obj2.wait(); => 40 threads waiting

obj1.notifyAll() -> it will notify all the waiting thread of particular objects.


On which object we are calling wait method thread required lock of that particular object.
If we are calling wait method on s1 then we have to get lock of s1 object, but not on s2 object.

Stack s1 = new Stack();
Stack s2 = new Stack();

Synchronized(s1) {

s2.wait();

}
RE: IllegalMonitorStateException
-----------------------------------
Synchronized(s1) {

s1.wait();

}



6. InterThread communication

7. Deadlock

8. Demon Threads

9. Multithreading enhancement


